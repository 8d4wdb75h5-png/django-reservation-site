from django.shortcuts import render, redirect
from django.http import HttpResponseNotAllowed
from django.db import transaction
from django.utils.dateparse import parse_date
from .models import Slot,Reservation
from django.shortcuts import render, redirect, get_object_or_404
from django.utils import timezone
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.shortcuts import render
from django.db import models
from django.db.models import Sum, F
from django.db.models.functions import Coalesce

@login_required
def manage_home(request):
    return render(request, "manage/home.html")

def index(request):
    # ?date=YYYY-MM-DD を受け取る
    qdate_str = request.GET.get("date")
    qdate = parse_date(qdate_str) if qdate_str else None

    today = timezone.localdate()

    slots = (
        Slot.objects.filter(date__gte=today)
        .annotate(
            reserved=Coalesce(
                Sum(
                    "reservations__people",
                    filter=models.Q(reservations__status=Reservation.Status.ACTIVE),
                ),
                0,
            )
        )
        .order_by("date", "time")
    )

    now = timezone.localtime().time()
    slots = slots.exclude(date=today, time__lt=now)
    
    if qdate:
        if qdate < today:
            qdate = None # 過去日なら無効化(一覧出さない)
        else:
            slots = slots.filter(date=qdate)

    # flatpickr の enable 用（"YYYY-MM-DD" の配列）
    available_dates = (
        Slot.objects.filter(date__gte=today)
        .order_by("date")
        .values_list("date", flat=True)
        .distinct()
    )
    available_dates = [d.strftime("%Y-%m-%d") for d in available_dates]

    return render(request, "reservations/index.html", {
        "slots": slots,
        "qdate": qdate,
        "available_dates": available_dates,
    })


@transaction.atomic
def reserve(request, slot_id):
    if request.method != "POST":
        return HttpResponseNotAllowed(["POST"])

    slot = Slot.objects.select_for_update().get(id=slot_id)
    people = int(request.POST.get("people", 1))

    # 1未満はNG
    if people < 1:
        return redirect("reservations:index")
    
    # 残席より多い人数はNG
    if slot.remaining < people:
        return redirect("reservations:index")

    today = timezone.localdate()
    if slot.date < today:
        # messages を使うなら
        # messages.error(request, "過去の日付は予約できません")
        return redirect("reservations:index")

    # 予約レコードを作る (name/phoneは今フォームがなければ空でOK)
    name = request.POST.get("name","")
    phone = request.POST.get("phone","")

    reservation = Reservation.objects.create(
        slot=slot,
        name=name,
        phone=phone,
        people=people,
        status=Reservation.Status.ACTIVE,
    )

    # thanks画面でキャンセルできるようにID保存(最短実装)
    request.session["last_reservation_id"] = reservation.id
    return redirect("reservations:thanks")

def thanks(request):
    reservation_id = request.session.get("last_reservation_id")
    return render(request,"reservations/thanks.html", {
        "reservation_id":reservation_id
    })

@transaction.atomic
def cansel_reservation(request,reservation_id):
    if request.method !="POST":
        return HttpResponseNotAllowed(["POST"])
    
    reservation = get_object_or_404(
        Reservation.objects.select_for_update(),
        id=reservation_id
    )

    if reservation.status == Reservation.Status.CANCELED:
        return redirect("reservations:index")
    
    reservation.status = Reservation.Status.CANCELED
    reservation.save(update_fields=["status"])

    request.session.pop("last_reservation_id",None)

    return redirect("reservations:index")